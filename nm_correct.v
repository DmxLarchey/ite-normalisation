(**************************************************************)
(*   Copyright Dominique Larchey-Wendling    [*]              *)
(*             Jean-FranÃ§ois Monin           [+]              *)
(*                                                            *)
(*            [*] Affiliation LORIA -- CNRS                   *)
(*            [+] Affiliation VERIMAG - Univ. Grenoble-Alpes  *)
(**************************************************************)
(*      This file is distributed under the terms of the       *)
(*         CeCILL v2 FREE SOFTWARE LICENSE AGREEMENT          *)
(**************************************************************)

(** Using the simulated IR definition of 

                        ð”» : Î© -> Prop 
       and nm : forall e, ð”» e -> Î©

    we show show partial correctness of nm:

      a) if De : ð”» e then nm e De is normal

      b) if De : ð”» e then nm e De is equivalent to e

    both by dependent induction on De : ð”» e
*)

Require Import Arith Omega Wellfounded.

Require Import nm_defs.

Set Implicit Arguments.

(* Now we show the partial correctness of nm, independently of its termination *)

(** normal forms only have atoms as boolean condition ie. b in if b then _ else _ *)

Inductive normal : Î© -> Prop :=
  | in_normal_0 : normal Î±
  | in_normal_1 : forall y z, normal y -> normal z -> normal (Ï‰ Î± y z).

Notation â„• := normal.

(** nm produces normal forms *)

Theorem nm_normal e D : â„• (nm e D).
Proof.
  induction D as [ e D1 D2 | | y z D1 ID1 D2 ID2 | u v w y z D1 ID1 D2 ID2 D3 ID3 ].
  - rewrite (nm_pirr _ D1); auto.
  - rewrite nm_fix_0; constructor.
  - rewrite nm_fix_1; constructor; auto.
  - rewrite nm_fix_2; auto.
Qed.

(** equiv is the congruence generated by Ï‰ (Ï‰ a b c) y z ~e Ï‰ a (Ï‰ b y z) (Ï‰ c y z) *)

Reserved Notation "x '~Î©' y" (at level 70, no associativity).

Inductive equiv : Î© -> Î© -> Prop :=
  | in_eq_0 : forall u v w y z, Ï‰ (Ï‰ u v w) y z ~Î© Ï‰ u (Ï‰ v y z) (Ï‰ w y z)
  | in_eq_1 : forall x x' y y' z z', x ~Î© x' -> y ~Î© y' -> z ~Î© z'-> Ï‰ x y z ~Î© Ï‰ x' y' z'
  | in_eq_2 : Î± ~Î© Î±
  | in_eq_3 : forall x y z, x ~Î© y -> y ~Î© z -> x ~Î© z
where "x ~Î© y" := (equiv x y).

Hint Constructors equiv.

Fact equiv_refl e : e ~Î© e.
Proof. induction e; auto. Qed.

Hint Resolve equiv_refl.

Notation equiv_trans := in_eq_3.

(** nm preserves equivalence *)

Fact nm_equiv e D : e ~Î© nm e D.
Proof.
  induction D as [ e D1 D2 | | y z D1 ID1 D2 ID2 | u v w y z D1 ID1 D2 ID2 D3 ID3 ].
  - rewrite (nm_pirr _ D1); auto.
  - rewrite nm_fix_0; auto.
  - rewrite nm_fix_1; auto.
  - rewrite nm_fix_2.
    apply equiv_trans with (2 := ID3),
          equiv_trans with (1 := in_eq_0 _ _ _ _ _); auto.
Qed.


